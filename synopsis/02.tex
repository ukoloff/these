%!TEX root = ../synopsis.tex

В {\bf третьей главе}
исследуется
применение непрерывно-дискретных моделей оптимизации
в САПР УП машин листовой резки с~ЧПУ
на примере
задачи непрерывной резки {\it CCP}
на Евклидовой плоскости
$\mathbb R \times \mathbb R$.
Возьмём
$N$
попарно непересекающихся плоских контуров
$\{C_1, C_2, ... C_N\}$.
В данной работе рассматриваются только контуры
$C_i$,
состоящие из
отрезков прямых линий и дуг окружностей
--
именно такие геометрические примитивы
поддерживаются программным обеспечением
современного оборудования фигурной резки с~ЧПУ.
Выберем также точки
$M_0$, $M_{N + 1}$
--
начало и конец
маршрута резки.
Задача непрерывной резки
({\it Continuous Cutting Problem, CCP})
состоит в поиске:
$N$ точек врезки $M_i \in C_i, i \in \overline{1, N}$
и последовательности обхода контуров
$C_i$
(перестановки
$N$
элементов
$I = (i_1, i_2, ... i_N)$).
Результатом решения задачи будет являться маршрут
\begin{equation}
  \label{eq:route}
  \mathcal R =
  \left<M_0, M_{i_1}, M_{i_2}, \dots M_{i_N}, M_{N + 1}\right>
\end{equation}
Целевая функция
сводится фактически к минимизации длины холостого хода
$
\mathcal{L} \to \min
$,
где
\begin{equation}
  \mathcal{L} = \sum_{j=0}^N|M_{i_j}M_{i_{j+1}}|
  ,
  \label{air-move-length}
\end{equation}
здесь для простоты записи мы полагаем
$M_{i_0} = M_0$,
$M_{i_{N + 1}} = M_{N + 1}$.

Кроме того, решение должно удовлетворять ограничению предшествования:
если
$\widetilde C_i$
обозначает 2-мерную фигуру,
ограниченную контуром
$C_i$
(в более традиционных обозначениях
$C_i = \partial \widetilde C_i$),
то
$
 \widetilde C_p \subset \widetilde C_q \Rightarrow i_p < i_q
$,
то есть вложенный контур должен быть посещён раньше,
чем содержащий его,
и не все перестановки
$I = (i_1, i_2, ... i_N)$
допустимы.

Предлагаемый алгоритм
~\cite{berlin2019,bi:ccp:ru}
решения задачи:
1) удаление <<внешних>> контуров;
2) поиск положений точек врезки (непрерывная оптимизация);
3) поиск порядка обхода контуров (дискретная оптимизация без учёта ограничений предшествования);
4) восстановление удалённых контуров.

На первом шаге мы удаляем все контура,
внутри которых содержатся другие,
то есть оставляем только
$
\{C_i \vert \forall j \ne i\colon C_j \cap \widetilde C_i = \varnothing \}
$,
тем самым как правило сокращая размерность задачи с $N$
до некоторого $N' \leqslant N$.

На втором шаге мы предполагаем перестановку контуров
$I = (i_1, i_2, ... i_N)$
фиксированной,
выбираем произвольные положения точек врезки
$M_i \in C_i$ на контурах и подвергаем их последовательной релаксации:
для каждой точки $M_i$
мы полагаем все остальные $M_j$ $(i\ne j)$ фиксированными и находим
положение $M_i$, минимизирующее функционал
$$
|M_{i-1}M_i|+|M_iM_{i+1}| \to \min_{M_i \in C_i}
$$

На практике этот процесс очень быстро сходится,
давая за время $O(N')$
позиции точек врезки на всех контурах.

На третьем шаге предполагается воспользоваться каким-либо
методом дискретной оптимизации для поиска перестановки
$I = (i_1, i_2, ... i_N)$.
В данной диссертационной работе использован метод
переменных окрестностей
(Variable Neighborhood Search,
VNS
\autocite{bi:VNS}).
Мы также начинаем с произвольной
(случайной) перестановки $I$,
строим окрестность этой перестановки
$\mathcal N(I)$
(например, все перестановки,
полученные из неё всеми однократными попарными перестановками контуров),
для каждой перестановки $I'\in \mathcal N(I)$
находим оптимальные позиции точек врезки
для минимизации холостого хода
$$
\mathcal L (I') = \min_{M_i\in C_i, \forall i}
  \mathcal L (M_1, M_2 \dots M_N | I')
$$
(как описано выше на втором шаге алгоритма)
и выбираем ту из перестановок $I'$,
которая даёт наименьшее значение длины
холостого хода \eqref{air-move-length},
и к ней применяется этот же процесс.
Если же понизить длину холостого хода не получается,
рассматриваются всё более широкие окрестности
$\mathcal N(I)$
(например, полученные тройными перестановками контуров
и т.п.),
пока не будет обнаружена перестановка $I$,
которая уже не может быть улучшена.
Она и считается решением задачи
вместе с соответствующими ей позициями точек врезки.

На четвёртом и последнем шаге алгоритма
мы восстанавливаем контуры,
удалённые на первом шаге и находим точки
врезки и для них как пересечение маршрута
$
\mathcal R = \left< M_0, M_1, M_2, \dots M_{N'}, M_{N+1}\right>
$
с каждым из (удалённых) контуров
$M_i = C_i \cap \mathcal R$,
причём из нескольких таких точек
выбирается самая последняя по ходу маршрута
$\mathcal R$.
После добавления таким образом всех
<<внешних>> контуров
и соответствующих им точек врезки,
мы получаем уже полный маршрут,
который посещает все исходные контуры,
причём внутренние контуры посещаются
строго раньше содержащих их внешних.
Получаемый таким образом
за линейное время
$O(N)$
полный маршрут
является оптимальным решением исходной задачи
непрерывной резки,
соблюдающим
ограничение предшествования.

С практической точки зрения
алгоритм работает очень хорошо,
быстро находя хорошие маршруты резки.
Однако, объективная оценка качества решения сложна.
В данной работе в качестве базы сравнения использовался алгоритм
на основе динамического программирования
\autocite{bi:RoMa},
который находит точное решение задачи GTSP
для количества контуров
$N \leqslant 33$.
Использовались несколько раскройных планов,
содержащих реальные детали,
см. табл.~\ref{tab:ccp-vs-gtsp}.

\begin{figure}
  \centering
  \subfloat[Точное решение задачи PCGTSP]{
    \label{fig:gtsp-path}
    \includegraphics[width=0.45\textwidth]{464-gtsp.png}
  }
  \subfloat[Решение задачи CCP]{
    \label{fig:ccp-path}
    \includegraphics[width=0.45\textwidth]{464-ccp.png}
    }
  \caption{Решения задач резки для задания № 464}
  \label{fig:solutions-path}
\end{figure}

\begin{table}
  \centering
  \caption{Сравнение качества решений задач CCP и GTSP}
  \label{tab:ccp-vs-gtsp}
  \def\arraystretch{1.2}
  \begin{tabular}{l|*{3}{r}}
      Задание & № 229 & № 464 & № 3211 \\
      \hline
      Кол-во деталей & 11 & 14 & 17\\
      Кол-во контуров & 12 & 21 & 22 \\
      Общий периметр, м & 24.609 & 21.717 & 25.051 \\
      Кол-во точек GTSP & 491 & 429 & 493 \\
      $\mathcal L_{GTSP}$, м & 7.729 & 4.743 & 4.557 \\
      $\mathcal L_{CCP}$, м & 7.727 & 4.706 & 4.536 \\
      \hline
  \end{tabular}
\end{table}

На рис. \ref{fig:gtsp-path}
показано точное решение задачи GTSP,
а на рис. \ref{fig:ccp-path}
--- решение задачи непрерывной резки,
полученное вышеописанным алгоритмом
для того же раскройного плана.
Видно,
что оба алгоритма дают практически идентичные
маршруты резки.
Основное отличие вызвано необходимостью дискретизации
контуров в ходе сведения задачи
непрерывной резки к GTSP.
Это приводит, в частности к тому,
что длина холостого хода в задаче GTSP
получается немного больше,
чем в задаче CCP,
что видно в табл.~\ref{tab:ccp-vs-gtsp}.
