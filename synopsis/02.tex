%!TEX root = ../synopsis.tex

Во {\bf второй главе} 
рассматривается задача непрерывной резки {\it CCP}
на Эвклидовой плоскости
$\mathbb R \times \mathbb R$.
Возьмём
$N$
попарно непересекающихся плоских контуров
$\{C_1, C_2, ... C_N\}$,
ограничивающих
$n$
деталей
$\{A_1, A_2, ... A_n\}$.
В общем случае
$n \leqslant N$.
В данной работе рассматриваются только контуры 
$C_i$,
состоящие из
(конечного числа)
отрезков прямых линий и дуг окружностей,
так как именно такие геометрические примитивы
поддерживаются программным обеспечением
современных машин термической резки с ЧПУ.
Выберем также две точки 
$M_0$, $M_{N + 1}$
(почти всегда $M_0 = M_{N + 1}$),
которые будут использоваться
как начало и конец
маршрута резки.
Задача непрерывной резки
({\it Continuous Cutting Problem, CCP})
состоит в поиске:
\begin{enumerate}
\item
$N$ точек врезки $M_i \in C_i, i \in \overline{1, N}$
\item
Последовательности обхода контуров
$C_i$,
то есть перестановки
$N$
элементов
$I = (i_1, i_2, ... i_N)$
\end{enumerate}
Результатом решения задачи будет являться маршрут
\begin{equation}
  \{M_0, M_{i_1}, M_{i_2}, \dots M_{i_N}, M_{N + 1}\}
\end{equation}
Целевая функция
сводится фактически к минимизации длины холостого хода:
\begin{equation}
  \mathcal{L} = \sum_{j=0}^N|M_{i_j}M_{i_{j+1}}|
  \label{air-move-length}
\end{equation}
$$
\mathcal{L} \to \min
$$
где, для простоты записи мы полагаем
$M_{i_0} = M_0$,
$M_{i_{N + 1}} = M_{N + 1}$.

Кроме того, решение должно удовлетворять ограничению предшествования:
если
$\widetilde C_i$
обозначает 2-мерную фигуру,
ограниченную контуром
$C_i$
(в более традиционных обозначениях
$C_i = \partial \widetilde C_i$),
то 
$
 \widetilde C_p \subset \widetilde C_q \Rightarrow i_p < i_q 
$,
то есть вложенный контур должен быть посещён раньше,
чем содержаший его,
и не все перестановки
$I = (i_1, i_2, ... i_N)$
допустимы.

Предлагаемый алгоритм
(см.~\cite{berlin2019})
решения задачи:

\begin{enumerate}
  \item Удаление <<внешних>> контуров
  \item Поиск положений точек врезки (непрерывная оптимизация)
  \item Поиск порядка обхода контуров (дискретная оптимизация без учёта ограничений предшествования)
  \item Восстановление удалённых контуров
\end{enumerate}

На первом шаге мы удаляем все контура,
внутри которых содержатся другие, 
то есть оставляем только
$$
\{C_i | \forall j \ne i: C_j \cap \widetilde C_i = \varnothing \},
$$
тем самым как правило сокращая размерность задачи с $N$
до некоторого $N' \leqslant N$.

На втором шаге мы предполагаем перестановку контуров 
$I = (i_1, i_2, ... i_N)$
фиксированной,
выбираем произвольные положения точек врезки
$M_i \in C_i$ на контурах и подвергаем их последовательной релаксации:
для каждой точки $M_i$
мы полагаем все остальные $M_j$ $(i\ne j)$ фиксированными и находим
положение $M_i$, минимизирующее функционал
$$
|M_{i-1}M_i|+|M_iM_{i+1}| \to \min_{M_i \in C_i}
$$

На практике этот процесс очень быстро сходится,
получая за время $O(N')$
позиции точек врезки на всех контурах.

На третьем шаге предполагается воспользоваться каким-либо
методом дискретной оптимизации для поиска перестановки
$I = (i_1, i_2, ... i_N)$.
В данной диссертационной работе использован метод
переменных окрестностей
(Variable Neighborhood Search,
VNS).
Мы также начинаем с произвольной
(случайной перестановки $I$),
строим окрестность этой перестановки 
$\mathcal N(I)$
(например, все перестановки,
полученные из неё всеми однократными попарными перестановками контуров),
для каждой перестановки $I'\in \mathcal N(I)$
находим оптимальные позиции точек врезки 
для минимизации холостого хода 
$$
\mathcal L (I') = \min_{M_1, M_2 \dots M_N}
  \mathcal L (M_1, M_2 \dots M_N | I')
$$
(как описано выше на втором шаге алгоритма)
и выбираем ту из перестановок $I'$,
которая даёт наименьшее значение длины 
холостого хода \eqref{air-move-length},
и к ней применяется этот же процесс.
Если же понизить длину холостого хода не получается,
рассматриваются всё более широкие окрестности 
$\mathcal N(I)$
(например, полученные тройными перестановками контуров
и т.п.), 
пока не будет обнаружена перестановка $I$,
которая уже не может быть улучшена.
Она и считается решением задачи
вместе с соответствующими ей позициями точек врезки.

На четвёртом и последнем шаге алгоритма
мы восстанавливаем контуры,
удалённые на первом шаге и находим точки
врезки и для них как пересечение маршрута
\begin{equation}
  \label{route0}
  Route = \{ M_0, M_1, M_2, \dots M_{N'}, M_{N'+1}\}
\end{equation}
с каждым из (удалённых) контуров
$M_i = C_i \cup Route$,
причём из нескольких таких точек
выбирается самая последняя по ходу маршрута
$Route$.
После добавления таким образом всех
<<внешних>> контуров
и соответствующих им точек врезки,
мы получаем уже полный маршрут,
который посещает все исходные контуры,
причём внутренние контуры посещаются
строго раньше содержащих их внешних.
Полная длина маршрута
при этой операции,
очевидно,
не меняется.
Получаемый таким образом полный маршрут
является оптимальным решением исходной задачи
непрерывной резки,
при этом
мы строго выполняем
ограничение предшествования,
тратя на это линейное время
$O(N)$.
