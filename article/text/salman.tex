% !TeX root = ..
\section{Branch-and-bound algorithm}\label{sec:SA}

To solve the PCGTSP instance
$(G,\CX,\Pi)$,
we traverse the search tree in
Breadth First Search order
(see Algorithm~\ref{alg:bnb}).
Each node of this tree is associated with
a prefix
$\sigma = \left(V_{i_1}, V_{i_2}, \dots V_{i_r} \right)$,
where
$V_{i_j} \in \CX$,
$V_{i_1} = V_1$,
and
$r \in \{{1, \dots m}\}$.

\begin{algorithm}[h!]
\caption{BnB :: Main}\label{alg:bnb}
\hspace*{\algorithmicindent}{\bf Input}: the graph $G$, clusters $\CX$, the DAG $\Pi$ \\
\hspace*{\algorithmicindent}{\bf Output}: the tour and cost of optimal solution
\begin{algorithmic}[1]
    \STATE initialize $Q =$ empty queue
    \STATE start from $Root = V_1$
    \STATE $Q$.push($Root$)
    \WHILE{not $Q$.empty()}
        \STATE get prefix to process: $\sigma = Q$.pop()
        \STATE $process = Bound(\sigma)$
        \IF{\NOT $process$}
            \STATE prefix is fathomed; {\bf continue}
        \ENDIF
        \STATE $UpdateLowerBound(\sigma)$
        \FORALL{$child \in Branch(\sigma)$}
            \STATE queue child prefix $Q$.push($child$)
        \ENDFOR
    \ENDWHILE
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[h!]
\caption{BnB :: Bounding procedure}\label{alg:bnb:bound}
\hspace*{\algorithmicindent}{\bf Input}: the prefix $\sigma$ \\
\hspace*{\algorithmicindent}{\bf Output}: the flag if the prefix survives or is fathomed
\begin{algorithmic}[1]
    \STATE {\bf global} $D_{ij}^{\mathcal T}$
    \STATE {\bf global} $Opt^{\mathcal T}$
    \STATE calculate tuple $\mathcal T = \left(V_{i_1},
        \left\{V_{i_1}, V_{i_2}, \dots V_{i_r}\right\}, V_{i_r} \right)$
        \label{alg:bnb:bound:key}
    \STATE $D_{ij} = MinCosts(\sigma)$
        \label{alg:bnb:bound:pfx}
    \IF{$D_{ij}^{(\sigma)} \ge D_{ij}^{\mathcal T}[\mathcal T], \forall i, j$}
        \RETURN \FALSE
    \ENDIF
    \STATE  update best weights $D_{ij}^{\mathcal T}[\mathcal T]  = \min \left(
        D_{ij}^{\mathcal T}[\mathcal T], D_{ij} \right),
        \forall i, j$
    \STATE  $c_{min} = \min\limits_{i, j} D_{ij}$
    \IF{$\mathcal T \notin Opt^{\mathcal T}$}
        \STATE calculate bounds $Opt^{\mathcal T}[\mathcal T] = \max\left(L_1(\sigma), L_2(\sigma))\right)$
        \label{alg:bnb:bound:sfx}
    \ENDIF
    \STATE $\LB = c_{min} + Opt^{\mathcal T}[\mathcal T]$
        \label{alg:bnb:bound:lb}
    \IF{$\LB > \UB$}
        \RETURN \FALSE
    \ENDIF
    \RETURN \TRUE
\end{algorithmic}
\end{algorithm}

For each node of the search tree
we apply
the Bounding procedure
(Algorithm~\ref{alg:bnb:bound})
to perform the following actions:
\begin{itemize}
    \item
    for the prefix $\sigma$,
    we assign the tuple
    % $\mathcal T(\sigma)$
$$
\mathcal T(\sigma) = \left(V_{i_1},
        \left\{V_{i_1}, V_{i_2}, \dots V_{i_r}\right\}, V_{i_r} \right)
$$
    \item
    at step~\ref{alg:bnb:bound:pfx},
    we compute the matrix $D(\sigma)$ of minimal pairwise costs by the following formula:
    $$
    \hspace{-2ex}
    D(\sigma)_{vu} = \min\left\{
      cost(P_{v,u})\colon
      v \in V_{i_1},
      u \in V_{i_r},
      P_{v,u} \text{ is a partial $v$-$u$ path along } \sigma
    \right\}.
    $$
    This can be easily calculated
    incrementally using
    matrix $D(\sigma')$
    of parent tree node
    \item
    if, for some $\sigma_1$, $\mathcal T(\sigma) = \mathcal T(\sigma_1)$ and
    $$
    D(\sigma)_{vu} \ge D(\sigma_1)_{vu}, \quad
    (v \in V_{i_1}, u \in V_{i_r}),
    $$
    then,
    prefix $\sigma$ is dominated by $\sigma_1$
    and is fathomed
    \item
    at step~\ref{alg:bnb:bound:sfx},
    we calculate bounds $L_1$ and $L_2$,
    see Table~\ref{t:LBs} and assign the global variable
    $Opt^{\mathcal T}$ by the formula
    $$
    Opt^{\mathcal T(\sigma)} = \max(L_1, L_2)
    $$
    \item
    for current node $\sigma$,
    its lower bound is
    calculated by the formula
    $$
    \LB(\sigma) = \min_{vu}D(\sigma)_{vu} + Opt^{\mathcal T(\sigma)}
    $$
    at step~\ref{alg:bnb:bound:lb}
    \item
    finally, the node $\sigma$ is fathomed if $\LB > \UB$.
\end{itemize}

\begin{algorithm}
\caption{BnB :: Branching procedure}\label{alg:bnb:branch}
\hspace*{\algorithmicindent}{\bf Input}: the prefix $\sigma$ \\
\hspace*{\algorithmicindent}{\bf Output}: the list of children prefixes to process
\begin{algorithmic}[1]
    \STATE initialize $R =$ empty queue
    \FORALL{$V \in \CX$}
        \STATE $valid =$ \TRUE
        \FORALL{$W \in \sigma$}
            \IF{$W=V$ \OR $(V, W) \in \Pi$}
                \STATE $valid =$ \FALSE
                \STATE {\bf break}
            \ENDIF
        \ENDFOR
        \IF{$valid$}
            \STATE append new prefix $R$.push($\sigma+V$)
        \ENDIF
    \ENDFOR
    \RETURN $R$
\end{algorithmic}
\end{algorithm}

Nodes that survived are subjected to the
$Branch$ procedure
(Algorithm~\ref{alg:bnb:branch}),
where we try to enlarge the current prefix
$\sigma$
taking into account the precedence constraint $\Pi$.
