% !TeX root = ..
\section{Динамическое программирование}\label{sec:DP}
Алгоритм ветвей и границ,
описанный в разделе~\ref{sec:SA},
оказывается сильно связан с классической схемой,
использующей динамическое программирование (DP)
и носящей имя Хелда-Карпа
\cite{HeldKarp1962},
адаптированной для учёта ограничения предшествования
и дополненной стратегией отсечения,
представленной в основополагающей статье~\cite{MorinMarsten1976}.

\begin{algorithm}[t]
\caption{DP ::  индуктивное построение таблицы поиска}\label{alg:A2}
\hspace*{\algorithmicindent}\textbf{Вход:} орграф $G$, частичный порядок $\Pi$, слой таблицы поиска $\L_k$, верхняя граница $\UB$\\
% \hspace*{\algorithmicindent} \textbf{Parameters:} \textit{number\_of\_trials}, \textit{acceptance\_criterion}, \textit{termination\_criterion}\\
\hspace*{\algorithmicindent}\textbf{Выход:} $(k+1)$-ый слой $\L_{k+1}$
\begin{algorithmic}[1]
\STATE инициализация $\L_{k+1}=\varnothing$
\FORALL{$\CX'\in\I_k$}
  \FORALL{кластер $V_l\in\CX\setminus\CX'$, s.t. $\CX'\cup \{V_l\}\in\I_{k+1}$}
    \FORALL{$v\in V_1$ и $u\in V_l$}
      \IF{есть состояние $S=(\CX',U,v,w)\in\L_k$, s.t. $(w,u)\in E$}
      \STATE создаем новое состояние $S'=(\CX'\cup\{V_l\}, V_l, v, u)$
      \STATE $S'[cost] = \min\{S[cost] + c(w,u)\colon S=(\CX',U,v,w)\in\L_k\}$
      \STATE $S'[pred] = \arg\min\{S[cost] + c(w,u)\colon S=(\CX',U,v,w)\in\L_k\}$
      \STATE $S'[LB] = S'[cost] + \max\{L_1,L_2,L_3\}$
      \IF{$S'[\LB] \leqslant \UB$}
        \STATE добавляем $S'$ к $\L_{k+1}$
      \ENDIF
    \ENDIF
    \ENDFOR
  \ENDFOR
\ENDFOR
\RETURN $\L_{k+1}$
\end{algorithmic}
\end{algorithm}

В данной работе мы реализуем уточненную версию этой схемы 
для численной оценки производительности нашего алгоритма ветвей и границ.
Подобно классическому DP,
наш алгоритм состоит из двух этапов.
\begin{enumerate}
  \item
  На этом этапе таблица поиска строится инкрементально,
  в прямом направлении, 
  слой за слоем.
  Оптимальная стоимость для решаемой задачи
  находится после вычисления последнего $m$-го слоя.   
  \item
  Оптимальный маршрут реконструируется обратным просмотром 
  на основе данных, 
  хранящихся в таблице поиска.
\end{enumerate}

Каждое состояние DP
(запись в таблице поиска)
соответствует частичному 
$v$-$u$-пути
и индексируется кортежем
$(\CX',V_l,v, u)$, где
\begin{enumerate}
  \item
  $\CX'\subset \CX$ представляет собой \textit{идеал} частично упорядоченного множества кластеров $\CX$, то есть
  \[
    \forall (V\in\CX', V'\in\CX)\   (V',V)\in A) \Rightarrow (V'\in\CX');
  \]
  очевидно,
  в наших условиях,
  $V_1$ 
  принадлежит произвольному идеалу
  $\CX'\subset\CX$

  \item
  $V_l\subset\CX'$, 
  для которого нет 
  $V\in \CX'$, 
  такого, что
  $(V_l,V)\in A$
  \item
  $v\in V_1$, $u\in V_l$.
\end{enumerate}
Содержимое каждой записи DP
$S$ 
состоит из ссылки
$S[pred]$
на предшествующее состояние,
локальной нижней границы
$S[LB]$
и стоимости
$S[cost]$
соответствующего частичного 
$v$-$u$-пути.

Пусть $\I_k$
-- подмножество идеалов одного размера
$k\in\{1,\ldots,m\}$. 
Очевидно,
$\I_1=\{\{V_1\}\}$, 
а значит первый слой
$\L_1$
таблицы поиска строится тривиально.
Индуктивное построение остальных слоев
описано в Алгоритме~\ref{alg:A2}.

\subsection{Замечания}
\begin{enumerate}
  \item 
  Оптимум для решаемой задачи дается классическим уравнением Беллмана
  \[
    \mathrm{OPT}=\min_{v\in V_1}\min\{S[cost]+c(u,v)\colon S=(\CX',V_l, v, u)\in\L_m\}
  \]
  \item 
  По построению,
  размер таблицы поиска
  $O(n^2m\cdot |\I|)$. 
  Значит, время работы нашего алгоритма
  $O(n^3m^2\cdot |\I|)$. 
  В частности, 
  в случае частичного порядка фиксированной {\it ширины}
  $w$, $|\I|=O(m^w)$ \cite{Steiner-1990}. 
  Следовательно,
  оптимальное решение 
  PCGTSP 
  может быть найдено в этом случае за полиномиальное время
  даже без применения отсечения на шагах 10--12.

  \item
  После построения любого из слоев
  $\L_k$, 
  мы обновляем глобальное значение нижней границы,
  что приводит к сокращению общего разрыва.

  \item
  В нашей реализации,
  для повышения быстродействия
  мы вычисляем оценку $L_3$ 
  на шаге 9 
  только для небольшого количества состояний
  с наименьшей нижней границей.
\end{enumerate}

