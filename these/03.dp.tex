%!TEX root = ../these.tex

\section{Динамическое программирование}
\label{sec:pcgtsp.dp}

Алгоритм, описанный в разделе~\ref{sec:pcgtsp.bnb},
будучи реализован в ходе данной диссертационной работы,
оказался работоспособным и может применяться как
для оценки качества решений, полученных другими способами,
так и для поиска точных решений задачи PCGTSP.

Вместе с тем, дизайн в виде классической схемы ветвей и границ
проявил некоторые недостатки:

\begin{enumerate}
  \item
  Использование для нижней оценки
  одного минимального значения
  $c_{min}$
  вместо полной матрицы
  $D(\sigma)_{ij}$~\eqref{eq.pcgtsp.c_min.dp}
  представляется слишком сильным огрублением.
  \item
  Префиксы $\sigma$ обрабатываются независимо друг от друга,
  тогда как многие из них порождают
  одинаковую вспомогательную задачу
  $\mathcal P(\sigma)$~\eqref{eq:pcgtsp.cut.key}.
  Результаты ее решения требуется запоминать в глобальной переменной,
  что увеличивает расход памяти и затрудняет
  параллельное исполнение алгоритма.
\end{enumerate}

В то же время,
общее устройство алгоритма
представляется близким к классической схеме
динамического программирования
(Dynamic Programming, DP)
Хелда и Карпа
\cite{HeldKarp1962},
адаптированной для учёта ограничения предшествования
и дополненной стратегией отсечения,
представленной в основополагающей статье~\cite{MorinMarsten1976}.

По этим причинам
в рамках данной диссертационной работы
была разработана вторая версия алгоритма,
использующего соображения раздела~\ref{sec:pcgtsp.algo},
но в подходе DP.
Она традиционно состоит из двух этапов.
\begin{enumerate}
  \item
  Таблица динамического программирования строится в \textit{прямом направлении}
  инкрементально, слой за слоем.
  Оптимальное значение решаемой задачи находится
  после построения последнего $m$-го слоя.
  \item
  Оптимальный маршрут восстанавливается \textit{обратным ходом}
  по таблице,
  построенной на первом этапе.
\end{enumerate}

Каждое состояние DP
(ячейка таблицы динамического программирования)
соответствует частичному $v$-$u$-пути и индексируется кортежем
$(\mathcal C',V_l,v, u)$,
где
\begin{itemize}
  \item
  $\mathcal C'\subset \mathcal C$ представляет собой \textit{идеал}
  частично упорядоченного множества кластеров $\mathcal C$, то есть
  \[
    \forall V\in\mathcal C', V'\in\mathcal C \colon   (V',V)\in A \Rightarrow V'\in\mathcal C'
  \]

  Идеал $\mathcal C'$
  играет теперь ту же роль,
  что префикс $\sigma$
  в предыдущей версии алгоритма (раздел~\ref{sec:pcgtsp.bnb}),
  тем самым сводя все <<схожие>>
  префиксы вместе для обработки.
  Очевидно,
  в наших условиях,
  $V_1$
  принадлежит произвольному идеалу
  $\mathcal C'\subset\mathcal C$
  \item
  $V_l\subset\mathcal C'$,
  для которого нет
  $V\in \mathcal C'$,
  такого, что
  $(V_l,V)\in A$,
  то есть соблюдается ограничение предшествования.
  \item
  $v\in V_1$, $u\in V_l$.
\end{itemize}

Содержимое каждой записи DP
$S$
состоит из ссылки
$S[pred]$
на предшествующее состояние,
локальной нижней границы
$S[LB]$
и стоимости
$S[cost]$
соответствующего частичного
$v$-$u$-пути.

Пусть $\mathfrak I_k$
-- подмножество идеалов одного размера
$k\in\{1,\ldots,m\}$.
Очевидно,
$\mathfrak I_1=\{\{V_1\}\}$,
а значит первый слой
$\mathcal L_1$
таблицы поиска строится тривиально.
Индуктивное построение остальных слоев
описано в Алгоритме~\ref{alg:gtsp.dp}.

\begin{algorithm}[t]
  \caption{DP ::  индуктивное построение таблицы поиска}\label{alg:gtsp.dp}
  \textbf{Вход:} орграф $G$, частичный порядок $\Pi$, слой таблицы поиска $\mathcal L_k$\\
  \textbf{Выход:} $(k+1)$-ый слой $\mathcal L_{k+1}$
  \begin{algorithmic}[1]
  \STATE инициализация $\mathcal L_{k+1}=\varnothing$
  \FORALL{$\mathcal C'\in\mathfrak I_k$}
    \FORALL{кластер $V_l\in\mathcal C\setminus\mathcal C'$, s.t. $\mathcal C'\cup \{V_l\}\in\mathfrak I_{k+1}$}
      \FORALL{$v\in V_1$ и $u\in V_l$}
        \IF{есть состояние $S=(\mathcal C',U,v,w)\in\mathfrak L_k$, s.t. $(w,u)\in E$}
        \STATE создаем новое состояние $S'=(\mathcal C'\cup\{V_l\}, V_l, v, u)$
        \STATE $S'[cost] = \min\{S[cost] + c(w,u)\colon S=(\mathcal C',U,v,w)\in\mathcal L_k\}$
        \STATE $S'[pred] = \argmin\{S[cost] + c(w,u)\colon S=(\mathcal C',U,v,w)\in\mathcal L_k\}$
        \STATE $S'[LB] = S'[cost] + \max\{L_1,L_2,L_3\}$ \label{alg:pcgtsp.dp.LBs}
        \IF{$S'[LB] \leqslant UB$} \label{alg:pcgtsp.dp.cut}
          \STATE добавляем $S'$ к $\mathcal L_{k+1}$
        \ENDIF
      \ENDIF
      \ENDFOR
    \ENDFOR
  \ENDFOR
  \RETURN $\mathcal L_{k+1}$
  \end{algorithmic}
\end{algorithm}

\subsection*{Замечания}

\begin{enumerate}
  \item
  Оптимум для решаемой задачи дается классическим уравнением Беллмана
  \[
    \mathrm{OPT}=\min_{v\in V_1}\min\{S[cost]+c(u,v)\colon S=(\mathcal C',V_l, v, u)\in\mathcal L_m\}
  \]
  \item
  По построению,
  размер таблицы поиска
  $O(n^2m\cdot |\mathfrak I|)$
  и значит, время работы нашего алгоритма
  $O(n^3m^2\cdot |\mathfrak I|)$.
  В частности,
  в случае частичного порядка фиксированной ширины
  $w$, $|\mathfrak I|=O(m^w)$,
  см.~\cite{Steiner-1990}.
  Следовательно,
  оптимальное решение
  PCGTSP
  может быть найдено в этом случае за полиномиальное время
  даже без применения отсечения на шаге~\ref{alg:pcgtsp.dp.cut}.

  \item
  После построения любого из слоев
  $\mathcal L_k$,
  мы обновляем глобальное значение нижней границы,
  что улучшает точность аппроксимации.

  \item
  Для повышения быстродействия
  оценка $L_3$
  на шаге~\ref{alg:pcgtsp.dp.LBs}
  вычисляется
  только для небольшого количества
  ($\approx 1\%$)
  состояний с наименьшей нижней границей.
\end{enumerate}

