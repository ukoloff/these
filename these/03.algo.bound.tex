%!TEX root = ../these.tex

\subsection{Получение нижних оценок}
\label{sec:pgstcp.bound}

Используя подход динамического программирования
(Dynamic Programming, DP),
легко найти кратчайший путь
вдоль $\sigma$
между всеми парами вершин
$(v_1, v_r)$,
где
$v_1\in V_{i_1}, v_r\in V_{i_r}$
\begin{equation}
  \label{eq:pcgtsp.Cmin}
  c_{min}(\sigma)=\min_{\substack{v_1\in V_{i_1} \\ v_r\in V_{i_r}} } \left\{
    cost \left(P_{v_1, v_r}\right) \colon
    P_{v_1, v_r} \text{ --- частичный путь в порядке } \sigma \right\}
\end{equation}

Таким образом, исходная постановка задачи PCGTSP
может быть в каждом узле дерева поиска декомпозирована в две
(более простых) задачи:
\begin{enumerate}
  \item вычисление $c_{min}(\sigma)$
  \item задачу PCGTSP $\mathcal P(\sigma)$, полученную релаксацией исходной задачи PCGTSP следующим образом:
  \begin{itemize}
    \item использует те же ограничения предшествования
    \item содержит те же узлы и кластера,
    за исключением внутренних кластеров префикса
    $V_{i_2}, \dots V_{i_{r-1}}$
    \item ребра исходящие из $V_{i_1}$
    и входящие в $V_{i_r}$ удаляются
    \item веса ребер $c(u,v)$ сохраняются,
    \item для всех пар вершин
    $v_1\in V_{i_1}, v_r\in V_{i_r}$
    добавляются ребра нулевого веса
    $c(v_1, v_r)=0$
  \end{itemize}
\end{enumerate}

\begin{proposition}
\begin{multline}
  \label{eq:pcgtsp.decomposition}
  \min_T \{cost(T)| T \text{ начинается с префикса } \sigma\}
  \geqslant \\
  c_{min}(\sigma) + \min_{T}\{cost(T)| T \text{ -- допустимое решение задачи } \mathcal P(\sigma)\}
\end{multline}
\end{proposition}

\begin{proof}
  Любой маршрут $T$,
  начинающийся с префикса $\sigma$,
  делится на две части ---
  одну вдоль $\sigma$,
  вторую от $V_{i_r}$ до ${V_{i_1}}$.
  Первая имеет вес не менее $c_{min}(\sigma)$
  по определению.
  Вторая может быть дополнена подходящим ребром,
  идущим из $V_{i_r}$ в ${V_{i_r}}$
  (имеющим нулевой вес)
  и тем самым давая решение задачи
  $\mathcal P(\sigma)$.
\end{proof}

Нижняя оценка решения исходной задачи PCGTSP,
таким образом,
в каждом узле дерева поиска
$\sigma$
оценивается по формуле \eqref{eq:pcgtsp.decomposition}.
Важно заметить,
что многие задачи $\mathcal  P(\sigma)$
оказываются идентичными для разных $\sigma$
(отличающихся порядком посещения внутренних кластеров),
что позволяет значительно уменьшить общее время вычислений.

В то же время,
$\mathcal P(\sigma)$
все еще представляет собой экземпляр
задачи PCGTSP,
хотя и меньше размером,
чем исходная постановка.
Заменим ее решение в формуле~\eqref{eq:pcgtsp.decomposition}
на нижнюю границу,
полученную тем или иным способом
$$
\min_{T}\{cost(T)| T \text{ -- допустимое решение задачи } \mathcal P(\sigma)\}
\geqslant LB(\mathcal P(\sigma))
$$

В данной диссертационной работе для вычисления оценки
$LB(\mathcal P(\sigma))$
вслед за~\cite{SALMAN2020163}
используется трехступенчатая релаксация:
\begin{enumerate}
  \item $\mathcal P(\sigma) \to$ GTSP
  \item GTSP $\to$ ATSP
  \item ATSP $\to \mathcal P_{rel}(\sigma)$
\end{enumerate}
и решение задачи $\mathcal P_{rel}(\sigma)$
принимается за нижнюю границу
$LB(\mathcal P(\sigma))$:
\begin{equation}
  \label{eq:pcgtsp.LB}
  \min_T \{cost(T)| T \text{ начинается с префикса } \sigma\}
  \geqslant
  c_{min}(\sigma) + \mathrm{OPT}(\mathcal P_{rel})
\end{equation}

На всех шагах релаксации,
кроме первого,
используются несколько методов,
так что в общем случае получается \textit{несколько}
оценок
$\mathrm{OPT}(\mathcal P_{rel})$,
в формулу~\eqref{eq:pcgtsp.LB}
подставляется \textit{наибольшая} из них.
Опишем применявшиеся в данной диссертационной работе
методы релаксации задачи
$\mathcal P(\sigma)$
подробнее.

\subsubsection{Сведение PCGTSP к GTSP}

Для сведения
$\mathcal P(\sigma)$
к GTSP
необходимо снять ограничения предшествования.
Это можно сделать не полностью, а частично ---
ослабить
путем удаления ребер
$(v_p, v_q)$, которые заведомо запрещены
частичным порядком $\Pi$,
то есть
$(V(v_q), V(v_p))\in A$.
При этом маршрут из $v_q$ в $v_p$
все равно остается возможным,
но через одну или несколько промежуточных вершин.

Более строгий анализ показывает,
что можно удалить еще больше ребер.

Так, рассмотрим ребро
$(v_p, v_q)$,
которое формально соответствует частичному порядку $\Pi$
($(V(v_p), V(v_q))\in A$),
но существует промежуточный кластер $V^*$:
$(V(v_p), V^+), (V^+, V(v_q))\in A$.
Тогда ребро
$(v_p, v_q)$
тоже оказывается запрещено ограничениями предшествования,
так как любой допустимый маршрут
$v_p \to v_q$
должен проходить через некоторую вершину
$v^+ \in V^+$.
Для эффективного поиска таких
(запрещенных)
ребер
в данной диссертационной работе
заранее вычисляется
\textit{транзитивное сокращение}
орграфа $\Pi$,
то есть минимальный набор ребер
$A'$,
транзитивное замыкание которого дает $A$.
Например, в библиотеке NetworkX \cite{bi:NetworkX}
для вычисления транзитивного сокращения
имеется функция \textit{transitive\_reduction()}.
Тогда подлежат удалению ребра
$$
\left\{(v_p, v_q)|
  (V(v_p), V(v_q))\in A, (V(v_p), V(v_q))\notin A'\right\}
$$

Кроме того, отдельно следует рассмотреть ребра
$(v_p, v_q)$
в случае, когда
$v_q\in V_1$.
Для них условие удаления меняется на почти обратное:
остаются в графе только те ребра,
которые выходят из <<финальных>> кластеров,
то есть
$\nexists V^+ \colon (V(v_p), V^+)\in A$.

Поскольку мы ослабили ограничения предшествования,
то
$\mathrm{OPT}(\mathcal P) \geqslant \mathrm{OPT}(GTSP)$.

\subsubsection{Сведение GTSP к ATSP}
Частично выполнив таким образом ограничения предшествования,
далее сводим получившуюся задачу GTSP
к ATSP. Сделать это можно несколькими способами.

\begin{enumerate}
  \item Преобразование Нуна и Бина~\cite{NoonBean1993},
    сводящее GTSP к ATSP того же размера $n$
  \begin{itemize}
    \item
    Кластеры $V_i$
    (за исключением вырожденного случая $|V_i|=1$)
    замыкаются в циклы нулевого веса,
    то есть для каждой вершины $v_i$ добавляется ребро
    $c(v_i^-,v_i)=0$,
    где $v_i^- \in V(v_i)$ --- вершина, предшествующая $v_i$ в цикле,
    порядок замыкания вершин кластера в цикл --- произвольный
    \item
    Ребро $(v_i, v_j)$
    заменяется на ребро $(v_i^-,v_j)$
    того же веса.
  \end{itemize}
  \item
  \textit{Граф кластеров}
  $H_1 = (\mathcal C, A_1)$,
  индуцированный исходным графом $G$
  по правилу
  $$
    c(V_i, V_j)=\min_{\substack{v_i\in V_i \\ v_j \in V_j}}
    c(v_i,v_j)
  $$
  Тем самым получается задача ATSP размера $m$.
  Легко понять, что
  $LB(\mathcal P) \geqslant LB(H_1)$.
  \item
  Граф кластеров
  $H_2 = (\mathcal C, A_2)$,
  также индуцированный графом $G$,
  но используются веса путей длины 2,
  удовлетворяющих ограничениям предшествования
  $$
    c(V_i, V_j)=\min_{\substack{v_i\in V_i \\ v_j \in V_j \\ v_k\notin V_i, V_j}}
    \frac{c(v_i,v_k)+c(v_k,v_j)}{2}
  $$
  Можно доказать,
  что нижняя оценка на решение задачи ATSP
  для графа $H_2$
  является также нижней оценкой для
  построенной выше задачи GTSP,
  а значит и для исходной задачи
  $\mathcal P$.

  Причина использования графа $H_2$
  заключается в том, что
  граф $H_1$
  фактически не требует,
  чтобы маршрут входил и покидал кластер $V_i$
  через одну и ту же вершину $v_i \in V_i$,
  а использование путей длины 2
  автоматически учитывает это требование,
  хотя бы частично.

  При построении $H_2$
  ограничения предшествования учитываются сложнее,
  чем для преобразования Нуна и Бина или графа $H_1$:
  оба ребра
  $(v_i, v_k)$ и $(v_k, v_j)$
  должны быть допустимы с точки зрения ослабленных
  ограничений предшествования,
  описанных выше.
  \item
  Графы кластеров $H_3, H_4$ и т.д. ---
  строятся аналогично $H_2$,
  но при помощи путей большей длины,
  что позволяет получить альтернативные нижние оценки.
  Ввиду того,
  что построение таких графов заметно сложнее алгоритмически,
  в данной диссертационной работе они не использовались.
\end{enumerate}

\subsubsection{Релаксация ATSP и ее решение}
Теперь задача,
подлежащая решению ещё упростилась,
теперь это просто TSP
(возможно, асимметричная)
и возможно меньшего размера $m<n$,
чем исходная.
Однако она все еще экспоненциально сложная,
поэтому еще раз упростим ее,
причем это тоже можно сделать несколькими способами.

\begin{enumerate}
  \item
  Дополнительно релаксируем полученную задачу ATSP,
  решая вместо нее задачу нахождения
  минимального остовного (ориентированного) дерева
  MSAP
  (Minimum Spanning Arborescence Problem)
  на том же графе.
  Фактически мы снимаем ограничение того,
  что степень каждой вершины полученного решения должна
  быть в точности два,
  и вместо цикла ищем вершинное покрытие
  в виде дерева,
  что может только понизить вес ответа:
  $\mathrm{OPT}(MSAP) \leqslant \mathrm{OPT}(ATSP)$
  \item
  Вместо задачи ATSP решаем задачу циклового покрытия
  (Cycle cover) того же графа.
  В этом случае мы снимаем требование единственности цикла,
  в результате чего сложность задачи понижается с экспоненциальной
  до полиномиальной,
  а стоимость решения тоже может уменьшиться.

  С практической точки зрения,
  задача циклового покрытия решается как
  задача о назначениях
  (Assignment Problem, AP)
  на двудольном орграфе,
  обе доли которого конгруэнтны
  графу задачи ATSP.
  \item
  И наконец,
  для задач ATSP
  небольшого размера
  \textit{в некоторых случаях}
  она может быть прямо решена
  за разумное время одним
  из известных алгоритмов.
  В данной диссертационной работе
  для этого использовался MILP-солвер
  Gurobi~\cite{bi:Gurobi},
  оснащенный моделью
  ATSPxy~\autocite{SARIN2005}.
  Последняя способна решать не только
  классическую задачу ATSP,
  но и ATSP с ограничениями предшествования,
  поэтому в этом варианте они прямо
  добавлялись в условие задачи.

  Для обращения к Gurobi
  использовался пакет gurobipy~\cite{bi:GurobiPy}.
\end{enumerate}

В результате комбинирования описанных выше методов
получения нижней оценки для задачи
$\mathcal P(\sigma)$,
получается целый ряд различных оценок,
которые сведены в~Табл.~\ref{tab:pcgtsp.LBs}.
Ее столбцы представляют собой способы релаксации
задачи GTSP к ATSP,
а строки --- способы релаксации и решения
задачи ATSP.

\begin{table}
  \centering
  \caption{Методы оценки нижней границы}\label{tab:pcgtsp.LBs}
  \begin{tabular}[t]{*{5}{|c}|}
      \hline
      & \textbf{Нун и Бин} & $\mathbf{H_1}$ & $\mathbf{H_2}$ & $\mathbf{H_{3+}}$\\
      \hline \hline
    \textbf{AP / Цикловое покрытие} & $E_1$ & $\mathbf{L_1}$ & $\mathbf{L_2}$ & - \\
    \textbf{MSAP / Остовное дерево} & $E_2$ & $E_3$ & $E_4$ & - \\
    \textbf{Gurobi + ATSPxy} & $E_5$ & $\mathbf{L_3}$ & $E_6$ & -\\
    \hline
  \end{tabular}
\end{table}

Опираясь на результаты численных экспериментов
(см.~Табл.~\ref{tab:pcgtsp.vsL3}),
были отобраны наилучшие оценки,
обозначенные $L_1$--$L_3$,
так как они оказались наиболее точными
с доверительной вероятностью 95\%.
Оценки $E_1$--$E_3$
систематически оказываются ниже,
а оценки $E_5$ и $E_6$
к тому же значительно более трудоемки
в смысле времени счета.
Таким образом,
далее в данной диссертационной работе
суммарная нижняя оценка рассчитывается по формуле
$$
LB(\sigma) = c_{min}(\sigma) + \max_{i\in\{1,2,3\}} L_i(\mathcal P(\sigma))
$$

\begin{table}
  \centering
  \caption{Сравнение нижних оценок с оценкой $L_3$}
  \label{tab:pcgtsp.vsL3}
  \begin{tabular}[t]{|c||c||c|}
    \hline
    $E_1$ & $E_2=E_3$ & $E_4$ \\
    $0.48\pm0.03$ &	$0.54\pm0.01$ &	$0.60\pm0.002$ \\
    \hline\hline
    $L_1$ & $L_2$ & $L_3$ \\
    $0.91\pm0.02$	& $0.97\pm0.02$ & $1.00$ \\
    \hline
  \end{tabular}
\end{table}
