%!TEX root = ../these.tex

\subsection{Отсечение}
\label{sec:pgstcp.cut}

Для каждого узла дерева поиска,
задаваемого префиксом
$\sigma=(V_{i_1}, V_{i_2}, \dots V_{i_r})$,
алгоритм принимает решение
о возможном отсечении.
Для этого используются два соображения:

\begin{enumerate}
  \item На основе минимальной длины $c_{min}(\sigma)$
  \item На основе нижней оценки $LB(\sigma)$~\eqref{eq:pcgtsp.LB3}
\end{enumerate}

Рассмотрим их подробнее.

\subsubsection{%
Отсечение по длине путей вдоль префикса
}

Для быстрого инкрементального расчета
минимального пути вдоль префикса
$c_{min}(\sigma)$
методом динамического программирования
на самом деле требуется рассчитывать
и запоминать целую матрицу
\begin{equation}
  \label{eq:pcgtsp.cut.matrix}
D(\sigma)_{ij} = \min\left\{
  cost(P_{v_i,v_j})\colon
  v_i \in V_{i_1},
  v_j \in V_{i_r},
  P_{v_i,v_j} \text{ -- путь $v_i$-$v_j$ в порядке } \sigma
\right\}
,
\end{equation}
потому что она легко вычисляется
инкрементально на основе такой же матрицы
родительского префикса $\sigma': |\sigma| = |\sigma'|+1$,
и очевидно
\begin{equation}
  \label{eq.pcgtsp.c_min.dp}
  c_{min}(\sigma) = \min_{ij} D(\sigma)_{ij}
  .
\end{equation}

Далее, как сказано выше,
все префиксы $\sigma$,
отличающиеся только порядком
посещения внутренних кластеров,
по построению имеют одну и ту же задачу
$\mathcal P(\sigma)$,
а значит одну и ту же ее нижнюю оценку.
Построим кортеж
\begin{equation}
  \label{eq:pcgtsp.cut.key}
  \mathcal T(\sigma) = (V_{i_1},
  \left\{V_{i_1}, V_{i_2}, \dots V_{i_r} \right\}, V_{i_r})
\end{equation}
и множество
$
\mathbb T(\sigma) =\{\sigma' \colon \mathcal T(\sigma')=\mathcal T(\sigma)\}$
всех префиксов,
дающих ту же вспомогательную задачу
$\mathcal P(\sigma')\equiv \mathcal P(\sigma)$.
На этом множестве найдём минимальную
(поэлементно)
матрицу расстояний
$$
D(\mathbb T(\sigma))_{ij} =
  \min_{\sigma' \in \mathbb T(\sigma)} D(\sigma')_{ij}
$$

Несложно понять, что если
\begin{equation}
  \label{eq:pcgtsp.cut.prefix}
  D(\sigma)_{ij} > D(\mathbb T(\sigma))_{ij},
  \forall i, j
  ,
\end{equation}
то вес любого пути,
начинающего префиксом $\sigma$
может быть уменьшен простой
перестановкой кластеров внутри этого префикса,
и следовательно заведомо
не является оптимальным решением задачи PCGTSP.
Значит, этот префикс может быть
безопасно отброшен и не участвовать в
дальнейших вычислениях.

\subsubsection{Отсечение по нижней оценке}

Если же условие~\eqref{eq:pcgtsp.cut.prefix}
не соблюдается,
алгоритм вычисляет
$c_{min}$
по формуле~\eqref{eq.pcgtsp.c_min.dp},
строит вспомогательную задачу
$\mathcal P(\sigma)$,
как описано в разделе~\ref{sec:pgstcp.bound}
(если она не была построена ранее,
для некоторого префикса
$\sigma' \in \mathbb T(\sigma)$)
и рассчитывает полную нижнюю оценку
$LB(\sigma)$
по формуле~\eqref{eq:pcgtsp.LB3}.

Вторая
(и основная)
стратегия отсечения заключается в отбрасывании узлов дерева поиска,
для которых
\begin{equation}
  \label{eq:pcgtsp.cut.lb}
  LB(\sigma)>UB
  ,
\end{equation}
где
$UB$ --- некоторая верхняя оценка на вес оптимального решения.
Разумно в качестве такой оценки
взять вес
\textit{любого}
решения исходной задачи PCGTSP,
полученного произвольным образом.
В данной диссертационной работе
для получения такого решения
используется эвристика
PCGLNS~\cite{KKP-optima2020},
которая запускается однократно
перед началом работы алгоритма
и за короткое время
(буквально несколько секунд)
дает решение,
близкое к оптимальному.

Чем ниже верхняя граница $UB$,
тем очевидно больше узлов дерева поиска
будет отброшено и тем меньше будет
полное время работы алгоритма.
